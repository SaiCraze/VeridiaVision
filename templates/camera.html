<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Veridia Vision - Smart Detection</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>♻️</text></svg>">

    <!-- Google Analytics -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZDVYQL279E"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-ZDVYQL279E');
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Montserrat:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">

    <!-- Use Flask's url_for for robust linking -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        /* --- Additions/Modifications for Camera Fit and Glow --- */
        #camera-view-wrapper {
            /* Existing styles */
            transition: box-shadow 0.3s ease-out; /* Smooth transition for glow */
        }

        #camera-view-wrapper.capturing-glow {
            box-shadow: 0 0 25px 10px rgba(0, 220, 130, 0.7); /* Brighter green glow */
            /* Or use a white glow: */
            /* box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.8); */
        }

        #camera-container video,
        #result-image-container img {
            display: block;
            width: 100%; /* Fill container width */
            height: auto; /* Adjust height based on aspect ratio */
            max-height: 100%; /* Don't exceed container height */
            object-fit: contain; /* Maintain aspect ratio, fit within bounds */
        }
        /* --- End Additions/Modifications --- */
    </style>
</head>
<body class="app-body">
    <!-- Start Detection Modal -->
    <div id="startModal" class="modal modal-visible"> <!-- Start visible -->
      <div class="modal-content start-modal-content">
        <h2>Ready to Scan?</h2>
        <p>Click the button below to start the camera and begin waste classification.</p>
        <button id="force-start-button" class="cta-button">Start Detection</button>
      </div>
    </div>

    <div id="camera-app-container">
        <!-- Header Bar -->
        <header id="app-header">
            <div class="logo-container">
                <span class="logo-icon">
                    <svg width="26" height="26" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M13 2C10.4288 2 7.9154 2.76244 5.77759 4.1909C3.63978 5.61935 1.97351 7.64968 0.991826 10.0251C0.0101517 12.4006 -0.252401 15.0144 0.250707 17.5362C0.753815 20.0579 1.98979 22.3743 3.80762 24.1921C5.62545 26.01 7.94189 27.2459 10.4636 27.749C12.9854 28.2521 15.5992 27.9895 17.9747 27.0078C20.3502 26.0262 22.3805 24.3599 23.809 22.2221C25.2374 20.0843 25.9999 17.5709 25.9999 14.9997C25.9999 11.4869 24.5777 8.10073 22.0498 5.57285C19.5219 3.04497 16.1357 1.62275 12.6229 1.62275L13 2Z" fill="#00DC82"/>
                        <path d="M16.6183 7.72656C16.9121 7.72656 17.193 7.84102 17.4018 8.04988C17.6107 8.25873 17.7251 8.53962 17.7251 8.83344V11.0472C18.8078 11.2852 19.787 11.8768 20.5051 12.7328C21.2232 13.5888 21.6341 14.6612 21.6736 15.78C21.713 16.8988 21.3786 18.0004 20.7207 18.9107C20.0627 19.8211 19.1207 20.487 18.0566 20.7978C16.9924 21.1086 15.8558 21.0442 14.8335 20.6148C13.8113 20.1855 12.9638 19.4167 12.4369 18.4371C11.91 17.4575 11.7326 16.327 11.9343 15.2329C12.136 14.1388 12.7051 13.1462 13.5487 12.4145C13.6158 12.3533 13.6971 12.3086 13.7861 12.2848C13.875 12.2611 13.9686 12.2591 14.0584 12.279C14.1482 12.2989 14.2313 12.3401 14.3007 12.3985C14.3701 12.4569 14.4237 12.5307 14.4565 12.6135C14.4893 12.6963 14.5 12.7853 14.488 12.8724C14.4759 12.9594 14.4415 13.0416 14.3878 13.1116C14.334 13.1815 14.2627 13.2371 14.1801 13.2731C14.0975 13.3091 14.0064 13.3245 13.9164 13.318C13.1855 13.897 12.6909 14.7381 12.543 15.6746C12.3951 16.6111 12.6049 17.5705 13.1318 18.3577C13.6586 19.1449 14.4653 19.7056 15.3871 19.9356C16.3089 20.1656 17.2845 20.0478 18.1183 19.6051C18.9521 19.1624 19.5871 18.4291 19.9105 17.5407C20.2339 16.6523 20.2211 15.6743 19.8745 14.7947C19.5279 13.9151 18.8731 13.1981 18.0282 12.7764C17.1834 12.3546 16.2069 12.2588 15.2943 12.5082V15.1671C15.2943 15.4609 15.1798 15.7418 14.971 15.9507C14.7621 16.1595 14.4812 16.274 14.1874 16.274C13.8936 16.274 13.6127 16.1595 13.4038 15.9507C13.195 15.7418 13.0805 15.4609 13.0805 15.1671V8.83344C13.0805 8.53962 13.195 8.25873 13.4038 8.04988C13.6127 7.84102 13.8936 7.72656 14.1874 7.72656H16.6183Z" fill="#003c1a"/>
                    </svg>
                </span>
                <!-- Use url_for for the home link -->
                <a href="{{ url_for('index') }}" class="logo-text">Veridia Vision</a>
            </div>
            <div class="controls-header">
                <div class="control-group">
                     <span class="material-symbols-rounded">volume_up</span>
                     <label for="tts-toggle">Voice</label>
                     <label class="switch">
                         <input type="checkbox" id="tts-toggle" checked>
                         <span class="slider round"></span>
                     </label>
                </div>
                <div class="control-group">
                    <span class="material-symbols-rounded">cameraswitch</span>
                    <label for="camera-select">Camera</label>
                    <select id="camera-select" class="camera-dropdown" disabled>
                        <option>Loading...</option>
                        <!-- Options populated by JS -->
                    </select>
                </div>
            </div>
             <!-- Home button now uses stopAndExit -->
             <button id="home-button" class="app-button" title="Stop and Return to Home">
                 <span class="material-symbols-rounded">stop_circle</span> <!-- Changed Icon -->
                 <span>Stop & Home</span> <!-- Changed Text -->
             </button>
        </header>

        <!-- Main Content Area -->
        <main id="main-content">
            <div id="camera-view-wrapper"> <!-- Added ID for glow effect target -->
                <!-- Video Feed Container -->
                <div id="camera-container" class="media-container">
                    <video id="video-feed" autoplay playsinline muted></video>
                     <!-- Loading/Processing Overlay -->
                     <div id="processing-overlay" class="overlay hidden">
                        <div class="spinner"></div>
                        <span>Analyzing...</span>
                     </div>
                     <!-- Error Overlay -->
                     <div id="error-overlay" class="overlay error-msg hidden">
                         <span class="material-symbols-rounded">error</span>
                         <span id="error-text">Error accessing camera.</span>
                     </div>
                 </div>
                 <!-- Result Image Container -->
                 <div id="result-image-container" class="media-container hidden">
                     <img id="result-image" alt="Classification Result">
                 </div>
            </div>

            <!-- Prediction Sidebar -->
            <aside id="prediction-sidebar">
                <div class="sidebar-header">
                    <span class="material-symbols-rounded">insights</span>
                    <h2>Detection Results</h2>
                </div>
                <div id="prediction-content" class="sidebar-content">
                    <!-- Content updated by JS -->
                    <p class="placeholder-text">Initializing...</p>
                </div>
                <div class="sidebar-footer">
                    <!-- Stop Button (now redundant with header button but kept for clarity if needed) -->
                    <button id="stop-detection-button" class="action-button stop-button hidden">
                        <span class="material-symbols-rounded">stop_circle</span>
                        <span>Stop & Exit</span>
                    </button>
                </div>
            </aside>
        </main>
    </div>

    <!-- Hidden canvas for frame grabbing -->
    <canvas id="canvas" style="display: none;"></canvas>

    <!-- JavaScript -->
    <script>
        // --- DOM Elements ---
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const cameraViewWrapper = document.getElementById('camera-view-wrapper'); // For glow
        const cameraContainer = document.getElementById('camera-container');
        const resultImageContainer = document.getElementById('result-image-container');
        const resultImage = document.getElementById('result-image');
        const predictionSidebar = document.getElementById('prediction-sidebar');
        const predictionContent = document.getElementById('prediction-content');
        const sidebarFooter = document.querySelector('.sidebar-footer');
        const stopDetectionButton = document.getElementById('stop-detection-button');
        const startModal = document.getElementById('startModal');
        const forceStartButton = document.getElementById('force-start-button');
        const ttsToggle = document.getElementById('tts-toggle');
        const cameraSelect = document.getElementById('camera-select');
        const processingOverlay = document.getElementById('processing-overlay');
        const errorOverlay = document.getElementById('error-overlay');
        const errorText = document.getElementById('error-text');
        const homeButton = document.getElementById('home-button'); // Now also functions as stop

        // --- State & Config ---
        let stream = null;
        let captureInterval = null;
        let resultTimeout = null;
        let sessionTimeoutId = null; // Timeout for the 1-minute session
        let glowTimeoutId = null; // Timeout for removing glow effect
        let isProcessing = false;
        let ttsEnabled = true;
        let currentDeviceId = null;
        let availableCameras = [];

        const CAPTURE_INTERVAL_MS = 5000; // Scan every 5 seconds
        const SESSION_TIMEOUT_MS = 60 * 1000; // 1 minute session timeout
        const GLOW_DURATION_MS = 300; // How long the glow effect lasts
        const RESULT_DISPLAY_MS = 3000; // How long to show result image
        const VIDEO_CONSTRAINTS = {
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: 'environment' // Default preference
            },
            audio: false
        };

        // --- Text-to-Speech (No changes needed) ---
        const synth = window.speechSynthesis;
        let voices = [];
        function populateVoiceList() {
             if(typeof speechSynthesis === 'undefined') { return; }
             voices = synth.getVoices().filter(voice => voice.lang.startsWith('en'));
             console.log("Available English voices:", voices.length);
        }
         if (typeof speechSynthesis !== 'undefined') {
             if (speechSynthesis.onvoiceschanged !== undefined) {
             speechSynthesis.onvoiceschanged = populateVoiceList;
             }
             let voiceInterval = setInterval(() => {
                 if (synth.getVoices().length) {
                     populateVoiceList();
                     clearInterval(voiceInterval);
                 }
             }, 200);
             setTimeout(() => clearInterval(voiceInterval), 2000);
         }

        function speak(text) {
            if (!ttsEnabled || !synth || !text) {
                 console.log("TTS Skipped:", {ttsEnabled, synth:!!synth, text});
                return;
            }
            if (synth.speaking) {
                console.log("Cancelling previous speech");
                synth.cancel();
            }
            setTimeout(() => {
             try {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.onerror = (event) => { console.error('SpeechSynthesisUtterance.onerror', event); };
                if (voices.length > 0) {
                         let preferredVoice = voices.find(voice => voice.name.includes('Google US English')) ||
                                             voices.find(voice => voice.lang === 'en-US') ||
                                             voices[0];
                     utterance.voice = preferredVoice;
                         console.log("Using voice:", preferredVoice.name);
                     } else {
                         console.warn("No English voices loaded, using default.");
                 }
                 utterance.pitch = 1;
                 utterance.rate = 1.1;
                 synth.speak(utterance);
             } catch (e) {
                 console.error("Error initiating speech:", e);
             }
            }, 50); // Small delay helps prevent cutting off rapidly
        }

        // --- UI Updates ---
        function showProcessing(show, message = "Analyzing...") {
            const overlayText = processingOverlay.querySelector('span');
            if (overlayText) overlayText.textContent = message;
            processingOverlay.classList.toggle('hidden', !show);
            isProcessing = show;
        }

        function showError(message, consoleError = null) {
            console.error("UI Error Displayed:", message, consoleError || '');
            errorText.textContent = message;
            errorOverlay.classList.remove('hidden');
            // Auto-hide error overlay
            clearTimeout(errorOverlay.timeoutId);
            errorOverlay.timeoutId = setTimeout(() => errorOverlay.classList.add('hidden'), 5000);
        }

        function updatePredictionContent(htmlContent) {
             predictionContent.innerHTML = htmlContent;
             const placeholder = predictionContent.querySelector('.placeholder-text');
             if (placeholder) placeholder.remove();
        }

        function resetPredictionContent(message = 'Scanning...') { // Default to Scanning
            predictionContent.innerHTML = `<p class="placeholder-text">${message}</p>`;
        }

        function triggerGlowEffect() {
            clearTimeout(glowTimeoutId); // Clear previous timeout if any
            cameraViewWrapper.classList.add('capturing-glow');
            glowTimeoutId = setTimeout(() => {
                cameraViewWrapper.classList.remove('capturing-glow');
            }, GLOW_DURATION_MS);
        }

        // --- Camera & Devices (No major changes needed) ---
        async function getCameraDevices() {
            console.log("getCameraDevices: Starting...");
            cameraSelect.disabled = true;
            cameraSelect.innerHTML = '<option>Loading Cameras...</option>';
            try {
                // Request permission early if needed
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');

                cameraSelect.innerHTML = '';
                if (availableCameras.length === 0) {
                     cameraSelect.innerHTML = '<option>No cameras found</option>';
                     showError("No video cameras found on this device.");
                     return;
                }

                cameraSelect.disabled = false;
                let selectedDeviceId = null;
                availableCameras.forEach((camera, index) => {
                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.textContent = camera.label || `Camera ${index + 1}`;
                    // Prefer back/environment camera
                    if (!selectedDeviceId && (camera.label.toLowerCase().includes('back') || camera.label.toLowerCase().includes('environment'))) {
                        option.selected = true;
                        selectedDeviceId = camera.deviceId;
                    }
                    cameraSelect.appendChild(option);
                });

                // Default to first camera if no preference matched
                if (!selectedDeviceId && availableCameras.length > 0) {
                     selectedDeviceId = availableCameras[0].deviceId;
                     cameraSelect.value = selectedDeviceId; // Set dropdown value
                 }

                currentDeviceId = selectedDeviceId;
                console.log("Initial Camera Device ID:", currentDeviceId);
                cameraSelect.addEventListener('change', handleCameraChange); // Attach listener here
                console.log("getCameraDevices: Success, found", availableCameras.length, "cameras.");

            } catch (err) {
                console.error("Error in getCameraDevices:", err);
                let userMessage = "Error accessing cameras.";
                if (err.name === "NotAllowedError") {
                    userMessage = "Camera permission denied. Please allow camera access in browser settings.";
                } else if (err.name === "NotFoundError") {
                    userMessage = "No suitable camera found on this device.";
                } else {
                    userMessage = `Camera Error: ${err.name}. Check connections or permissions.`;
                }
                showError(userMessage, err);
                cameraSelect.innerHTML = '<option>Camera Error</option>';
                availableCameras = []; // Reset on error
            }
            console.log("getCameraDevices: Finished.");
        }

        async function startCameraStream() {
             console.log("startCameraStream: Attempting to start...");
             stopStream(); // Ensure any old stream is stopped first
             errorOverlay.classList.add('hidden'); // Hide previous errors

            const constraints = { ...VIDEO_CONSTRAINTS };
             constraints.video = constraints.video || {}; // Ensure video object exists

             if (currentDeviceId) {
                 constraints.video.deviceId = { exact: currentDeviceId };
                 delete constraints.video.facingMode; // Don't specify both
                 console.log(`Requesting specific camera ID: ${currentDeviceId}`);
             } else if (availableCameras.length > 0) {
                 // Fallback if somehow currentDeviceId is null but cameras exist
                 constraints.video.deviceId = { exact: availableCameras[0].deviceId };
                 delete constraints.video.facingMode;
                 console.log(`Fallback: Requesting first available camera ID: ${availableCameras[0].deviceId}`);
             }
             else {
                 // Default if no specific device known
                 constraints.video.facingMode = 'environment';
                 console.log(`Requesting camera by facingMode: ${constraints.video.facingMode}`);
             }

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                await video.play();
                // Wait for metadata to ensure dimensions are available
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject; // Handle potential errors during loading
                 });
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                console.log(`startCameraStream: Success. Stream dimensions: ${video.videoWidth}x${video.videoHeight}`);
                cameraContainer.classList.remove('hidden');
                resultImageContainer.classList.add('hidden');
                return true; // Indicate success
            } catch (err) {
                console.error("Error starting camera stream:", err);
                let userMessage = `Camera Error: ${err.name}.`;
                 if (err.name === "NotAllowedError") {
                    userMessage = "Camera permission denied. Please allow access.";
                 } else if (err.name === "NotFoundError") {
                    userMessage = "Selected camera not found or is unavailable.";
                 } else if (err.name === "NotReadableError") {
                    userMessage = "Camera may be in use by another application.";
                 } else if (err.name === "OverconstrainedError") {
                    userMessage = `Camera doesn't support request. Try another camera.`;
                 } else {
                     userMessage = `Failed to start camera: ${err.name}. Check permissions/connections.`;
                 }
                showError(userMessage, err); // Show error to user via overlay
                stopStream(); // Clean up
                return false; // Indicate failure
            }
        }

        function stopStream() {
            if (stream) {
                console.log("Stopping existing stream.");
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                video.srcObject = null;
            }
        }

        async function handleCameraChange() {
             const selectedId = cameraSelect.value;
             if (selectedId === currentDeviceId || !selectedId) return; // No change or invalid selection

             currentDeviceId = selectedId;
             console.log("Camera selected via dropdown:", currentDeviceId);

             // Stop current processing and restart immediately with the new camera
             console.log("Restarting stream and scan for new camera...");
             clearTimeout(sessionTimeoutId); // Reset session timer on camera change
             sessionTimeoutId = null;
             clearInterval(captureInterval);
             captureInterval = null;
             clearTimeout(resultTimeout);
             resultTimeout = null;
             stopStream(); // Stop the old stream explicitly

             resetPredictionContent('Switching cameras...');
             showProcessing(true, 'Starting new camera...'); // Show processing during switch

             // Give a brief moment for resources to release before restarting
             await new Promise(resolve => setTimeout(resolve, 100));

             const success = await startCameraStream();
             showProcessing(false); // Hide processing overlay

             if (success) {
                 await startScanning(true); // Restart scanning immediately (pass flag to skip initial delay)
             } else {
                 // Error handled by startCameraStream, UI shows error message
                 resetPredictionContent('<p class="error-text">Failed to start selected camera.</p>');
                 removeStopButton(); // Hide stop button if camera fails
             }
        }

        // --- Scanning Logic ---
        async function startScanning(skipInitialDelay = false) {
            console.log("startScanning called. Skip delay:", skipInitialDelay);
            if (captureInterval) {
                console.warn("startScanning: Already scanning, exiting.");
                return;
             }

            console.log("Attempting to start scanning loop...");
            resetPredictionContent('Starting scan...'); // Initial message

            // Ensure camera is running or try starting it
            if (!stream || !stream.active) {
                const cameraStarted = await startCameraStream();
                if (!cameraStarted) {
                    resetPredictionContent('<p class="error-text">Camera unavailable. Cannot start scan.</p>');
                    // Keep modal hidden, error shown by startCameraStream
                    return; // Stop if camera fails to start
                }
            }

            // Camera should be running now
            createStopButton(); // Show stop button
            resetPredictionContent('Scanning...'); // Update status

            // Start the 1-minute session timeout
            clearTimeout(sessionTimeoutId); // Clear any previous timeout
            sessionTimeoutId = setTimeout(redirectToThankYou, SESSION_TIMEOUT_MS);
            console.log(`Session timeout set for ${SESSION_TIMEOUT_MS / 1000} seconds.`);

            const startDelay = skipInitialDelay ? 0 : 1000; // Shorter initial delay, 0 if skipping

            // Use timeout for first capture, then interval
            setTimeout(() => {
                 captureAndProcessFrame(); // Immediate first capture
                 // Schedule subsequent captures
                 clearInterval(captureInterval); // Ensure no duplicate intervals
                 captureInterval = setInterval(captureAndProcessFrame, CAPTURE_INTERVAL_MS);
                 console.log(`Capture interval set for every ${CAPTURE_INTERVAL_MS / 1000} seconds.`);
            }, startDelay);
        }

        // Combined function to stop everything and cleanup
        function stopEverything(reason = "User action") {
            console.log(`Stopping everything. Reason: ${reason}`);
            clearInterval(captureInterval);
            captureInterval = null;
            clearTimeout(resultTimeout);
            resultTimeout = null;
            clearTimeout(sessionTimeoutId); // Crucial: clear session timeout
            sessionTimeoutId = null;
            clearTimeout(glowTimeoutId); // Clear glow timeout
            cameraViewWrapper.classList.remove('capturing-glow'); // Ensure glow removed

            stopStream(); // Stop the camera stream

            if (synth && synth.speaking) {
                synth.cancel(); // Stop any ongoing speech
            }
            showProcessing(false); // Ensure processing overlay is hidden
            removeStopButton(); // Hide the stop button
            resetPredictionContent('Scan stopped.'); // Update sidebar
        }

        // Function called by buttons or timeout
        function stopAndExit() {
            stopEverything("Stop/Home button clicked");
            // Navigate home using Flask's url_for if possible, otherwise hardcoded path
            window.location.href = "{{ url_for('index') }}"; // Assumes 'index' is your home route name
        }

        // Function called by the session timeout
        function redirectToThankYou() {
            console.log("Session timeout reached. Redirecting to thank you page.");
            stopEverything("Session timeout");
             // Redirect to the /thank_you route (ensure this route exists in Flask)
            window.location.href = '/thank_you';
        }


        async function captureAndProcessFrame() {
            if (isProcessing || document.hidden) {
                console.log("Capture skipped:", { isProcessing, hidden: document.hidden });
                 return;
             }
             // Check stream validity before proceeding
            if (!stream || !stream.active || video.paused || video.ended || video.readyState < 3) {
                 console.warn("captureAndProcessFrame: Stream invalid or video not ready. Skipping frame.");
                 // Optional: Try to restart the stream? Could lead to loops if camera hardware issue.
                 // await startCameraStream(); // Be cautious with this.
                 // For now, just skip the frame and let the interval try again.
                 return;
             }

            console.log("Attempting to capture and process frame...");
            showProcessing(true, "Analyzing...");
            triggerGlowEffect(); // <<<<<<<< ADD GLOW EFFECT HERE
            clearTimeout(resultTimeout); // Clear previous result display timeout

            try {
                // Ensure canvas dimensions match video (might change if video restarted)
                 if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                     canvas.width = video.videoWidth;
                     canvas.height = video.videoHeight;
                     console.log("Canvas resized to video dimensions:", canvas.width, "x", canvas.height);
                 }
                 // Draw current video frame to canvas
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.88); // Use slightly higher quality if needed

                // Send frame to backend
                const response = await fetch("{{ url_for('process_frame') }}", { // Use url_for
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_data: imageDataUrl }),
                });

                const result = await response.json();
                showProcessing(false); // Hide processing overlay AFTER getting response

                if (!response.ok) {
                    // Throw detailed error from server response if available
                    throw new Error(result.status || result.error || `Server error: ${response.status} ${response.statusText}`);
                 }
                console.log("Processing result:", result);

                // Update UI with results
                resultImage.src = result.processed_image_data; // Update result image source
                updatePredictionContent(formatPredictionResult(result)); // Update sidebar
                if (result.status) speak(result.status); // Speak status if available

                // Show result image, hide video feed temporarily
                cameraContainer.classList.add('hidden');
                resultImageContainer.classList.remove('hidden');

                // Set timeout to switch back to live video feed
                resultTimeout = setTimeout(() => {
                    resultImageContainer.classList.add('hidden');
                    // Only show camera again if stream is still active
                    if (stream && stream.active) {
                        cameraContainer.classList.remove('hidden');
                    } else {
                        console.log("Result display timeout finished, but stream is inactive.");
                        // Optionally show an error or message if stream died
                    }
                 }, RESULT_DISPLAY_MS);

            } catch (error) {
                 console.error('Error processing frame:', error);
                 showProcessing(false); // Ensure overlay hidden on error
                 let userMessage = "Analysis Error.";
                if (error instanceof TypeError && error.message.includes('NetworkError')) {
                     userMessage = "Network Error: Cannot reach server.";
                 } else if (error instanceof SyntaxError) {
                     userMessage = "Error: Invalid server response.";
                 } else {
                     userMessage = `Analysis Failed: ${error.message || 'Unknown error'}`;
                 }

                 // Display error in the prediction sidebar
                 updatePredictionContent(`<p class="error-text">${userMessage}</p>`);
                 speak("Analysis failed."); // Generic audio feedback for error

                 // Ensure video feed (if active) or error placeholder is shown, not the (stale) result image
                 resultImageContainer.classList.add('hidden');
                 if (stream && stream.active) {
                     cameraContainer.classList.remove('hidden');
                 } else {
                     cameraContainer.classList.add('hidden'); // Hide if stream is dead
                     // Potentially show the error overlay on the camera view too?
                     // showError("Analysis failed, camera may be inactive.");
                 }
                 // Don't stop the interval on processing errors, let it try again
            }
        }

        function formatPredictionResult(result) {
            if (result.error) {
                return `<p class="error-text">${result.error}</p>`;
            }
            // Use boxes_found and check array length for robustness
            if (!result.boxes_found || !Array.isArray(result.object_details) || result.object_details.length === 0) {
                 return '<p class="placeholder-text">No classifiable objects detected in the frame.</p>'; // More specific message
            }

            let html = '<ul class="prediction-list">';
            result.object_details.forEach(detail => {
                 const objectName = detail.name ? detail.name.charAt(0).toUpperCase() + detail.name.slice(1) : 'Unknown Object'; // Capitalize
                 const classification = detail.classification || 'unclassified';
                 // Sanitize classification for CSS class (lowercase, letters/numbers only)
                 const classificationClass = classification.toLowerCase().replace(/[^a-z0-9]/g, '') || 'unclassified';

                 html += `
                     <li class="prediction-item ${classificationClass}">
                         <span class="object-name">${objectName}</span>
                         <span class="object-classification ${classificationClass}">${classification.toUpperCase()}</span>
                     </li>
                 `;
            });
            html += '</ul>';
            return html;
        }

        // --- Event Listeners ---
        stopDetectionButton.addEventListener('click', stopAndExit); // Sidebar stop button
        homeButton.addEventListener('click', stopAndExit); // Header stop/home button

        ttsToggle.addEventListener('change', () => {
             ttsEnabled = ttsToggle.checked;
             console.log("TTS Enabled:", ttsEnabled);
             if (ttsEnabled) {
                 speak("Voice feedback enabled.");
             } else if (synth && synth.speaking) {
                 synth.cancel(); // Stop speaking immediately if disabled
             }
        });

         // Handle page close/navigation
         window.addEventListener('beforeunload', () => {
             console.log("Page unloading, ensuring cleanup.");
             stopEverything("Page unload");
         });

        // --- Initialization ---
        async function initializeApp() {
            console.log("Initializing Camera App (waiting for user start)...");
            ttsToggle.checked = ttsEnabled;
            resetPredictionContent('Waiting to start...'); // Initial placeholder

            try {
                // Get devices ready beforehand, improves user experience
                await getCameraDevices();
                if (availableCameras.length === 0) {
                    console.error("Initialization failed: No cameras found.");
                    resetPredictionContent('<p class="error-text">No camera detected. Cannot start.</p>');
                    startModal.classList.remove('modal-visible'); // Hide modal if no cameras
                    startModal.style.display = 'none'; // Ensure it's hidden
                    // Error should have been shown by getCameraDevices
                } else {
                    // Cameras found, modal is already visible via CSS (.modal-visible)
                    console.log("Cameras found. Waiting for user to click Start Detection in modal.");
                }
            } catch (error) {
                console.error("Initialization error:", error);
                resetPredictionContent('<p class="error-text">Initialization failed.</p>');
                showError("Failed to initialize camera system.", error);
                startModal.classList.remove('modal-visible'); // Hide modal on init error
                startModal.style.display = 'none'; // Ensure it's hidden
            }

            console.log("Initialization sequence complete.");
        }

        // Listener for the modal's start button
        forceStartButton.addEventListener('click', async () => {
            console.log("Start Detection button clicked.");
            startModal.classList.remove('modal-visible'); // Hide modal visually
            // Use timeout to ensure CSS transition completes before potential blocking operations
            setTimeout(() => {
                 startModal.style.display = 'none'; // Fully hide modal
            }, 300); // Match modal fade-out time if any

            await startScanning(); // Start the scanning process
        });

        // Helper to show/hide the stop button(s)
        function createStopButton() {
             stopDetectionButton.classList.remove('hidden');
             // Maybe hide the Start button if it were visible? Not applicable here.
         }

         function removeStopButton() {
             stopDetectionButton.classList.add('hidden');
         }

        // Start the app initialization process when the script loads
        initializeApp();

    </script>
</body>
</html>
